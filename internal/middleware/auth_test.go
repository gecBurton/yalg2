package middleware

import (
	"testing"

	"bifrost-gov/internal/testutil"
	"bifrost-gov/plugins/auth"
	"github.com/google/uuid"
	"github.com/valyala/fasthttp"
	"gorm.io/gorm"
)

func setupAuthMiddlewareTest(t *testing.T) (*AuthMiddleware, *gorm.DB) {
	// Setup test database with auth models
	db := testutil.SetupTestDB(t, &auth.User{}, &auth.Session{})
	
	// Create auth middleware
	config := &AuthConfig{
		ProtectedRoutes: []string{"/v1/*", "/api/*"},
		PublicRoutes:    []string{"/auth/*", "/public/*"},
	}
	
	middleware, err := NewAuthMiddleware(config, db)
	if err != nil {
		t.Fatalf("Failed to create auth middleware: %v", err)
	}
	
	return middleware, db
}

func createTestUser(t *testing.T, db *gorm.DB) (*auth.User, string) {
	// Create test user
	user := &auth.User{
		ID:    uuid.New(),
		Sub:   "test-user-12345",
		Email: "test@example.com",
		Name:  "Test User",
	}
	
	if err := db.Create(user).Error; err != nil {
		t.Fatalf("Failed to create test user: %v", err)
	}
	
	// For testing, we'll use a mock JWT token
	// In real scenarios, this would be generated by the OIDC provider
	mockToken := "mock-jwt-token-for-" + user.Sub
	
	return user, mockToken
}

func TestAuthMiddleware_PublicRoutes(t *testing.T) {
	middleware, _ := setupAuthMiddlewareTest(t)
	
	testCases := []struct {
		path     string
		expected bool
	}{
		{"/auth/login", false},      // Public route
		{"/auth/callback", false},   // Public route
		{"/public/test", false},     // Public route
		{"/v1/chat/completions", true}, // Protected route
		{"/api/providers", true},    // Protected route
		{"/random/path", false},     // Not explicitly configured, defaults to public
	}
	
	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			needsAuth := middleware.needsAuthentication(tc.path)
			if needsAuth != tc.expected {
				t.Errorf("Path %s: expected needsAuthentication=%v, got %v", 
					tc.path, tc.expected, needsAuth)
			}
		})
	}
}

func TestAuthMiddleware_MatchesPattern(t *testing.T) {
	testCases := []struct {
		path     string
		pattern  string
		expected bool
	}{
		{"/v1/chat/completions", "/v1/*", true},
		{"/v1/text/completions", "/v1/*", true},
		{"/api/providers", "/api/*", true},
		{"/auth/login", "/auth/*", true},
		{"/auth/login", "/v1/*", false},
		{"/exact/match", "/exact/match", true},
		{"/exact/match", "/exact/different", false},
		{"/v1", "/v1/*", false}, // Edge case: prefix without trailing slash should not match
	}
	
	for _, tc := range testCases {
		t.Run(tc.path+"_"+tc.pattern, func(t *testing.T) {
			matches := matchesPattern(tc.path, tc.pattern)
			if matches != tc.expected {
				t.Errorf("matchesPattern(%s, %s): expected %v, got %v", 
					tc.path, tc.pattern, tc.expected, matches)
			}
		})
	}
}

func TestAuthMiddleware_PublicRouteAccess(t *testing.T) {
	middleware, _ := setupAuthMiddlewareTest(t)
	
	// Create a test handler that sets a response
	testHandler := func(ctx *fasthttp.RequestCtx) {
		ctx.SetStatusCode(fasthttp.StatusOK)
		ctx.SetBodyString("success")
	}
	
	// Wrap with auth middleware
	wrappedHandler := middleware.Handler(testHandler)
	
	// Test public route access
	ctx := &fasthttp.RequestCtx{}
	ctx.Request.SetRequestURI("/auth/login")
	ctx.Request.Header.SetMethod("GET")
	
	wrappedHandler(ctx)
	
	if ctx.Response.StatusCode() != fasthttp.StatusOK {
		t.Errorf("Expected status 200 for public route, got %d", ctx.Response.StatusCode())
	}
	
	if string(ctx.Response.Body()) != "success" {
		t.Errorf("Expected 'success' response body, got '%s'", string(ctx.Response.Body()))
	}
}

func TestAuthMiddleware_ProtectedRouteWithoutAuth(t *testing.T) {
	middleware, _ := setupAuthMiddlewareTest(t)
	
	// Create a test handler
	testHandler := func(ctx *fasthttp.RequestCtx) {
		ctx.SetStatusCode(fasthttp.StatusOK)
		ctx.SetBodyString("should not reach here")
	}
	
	// Wrap with auth middleware
	wrappedHandler := middleware.Handler(testHandler)
	
	// Test protected route without auth
	ctx := &fasthttp.RequestCtx{}
	ctx.Request.SetRequestURI("/v1/chat/completions")
	ctx.Request.Header.SetMethod("POST")
	// No Authorization header
	
	wrappedHandler(ctx)
	
	if ctx.Response.StatusCode() != fasthttp.StatusUnauthorized {
		t.Errorf("Expected status 401 for protected route without auth, got %d", ctx.Response.StatusCode())
	}
	
	expectedBody := `{"error":"Authentication required"}`
	if string(ctx.Response.Body()) != expectedBody {
		t.Errorf("Expected error response, got '%s'", string(ctx.Response.Body()))
	}
}

func TestAuthMiddleware_ProtectedRouteWithInvalidAuth(t *testing.T) {
	middleware, _ := setupAuthMiddlewareTest(t)
	
	// Create a test handler
	testHandler := func(ctx *fasthttp.RequestCtx) {
		ctx.SetStatusCode(fasthttp.StatusOK)
		ctx.SetBodyString("should not reach here")
	}
	
	// Wrap with auth middleware
	wrappedHandler := middleware.Handler(testHandler)
	
	testCases := []struct {
		name   string
		header string
	}{
		{"Invalid format", "InvalidToken"},
		{"Missing Bearer", "Token abc123"},
		{"Invalid JWT", "Bearer invalid-jwt-token"},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ctx := &fasthttp.RequestCtx{}
			ctx.Request.SetRequestURI("/v1/chat/completions")
			ctx.Request.Header.SetMethod("POST")
			ctx.Request.Header.Set("Authorization", tc.header)
			
			wrappedHandler(ctx)
			
			if ctx.Response.StatusCode() != fasthttp.StatusUnauthorized {
				t.Errorf("Expected status 401 for invalid auth, got %d", ctx.Response.StatusCode())
			}
		})
	}
}

// Note: Testing with valid JWT tokens requires mocking the OIDC verifier
// or using integration tests with a real OIDC provider. Here's a basic structure:

func TestAuthMiddleware_ValidAuthFlow(t *testing.T) {
	// This test would require mocking the OIDC verifier
	// For now, we'll skip it and focus on the routing logic
	t.Skip("Valid auth flow test requires OIDC verifier mocking")
	
	middleware, db := setupAuthMiddlewareTest(t)
	
	// Create test user
	user, mockToken := createTestUser(t, db)
	
	// TODO: Mock the OIDC verifier to return valid claims for mockToken
	// This would require dependency injection or interface mocking
	
	testHandler := func(ctx *fasthttp.RequestCtx) {
		// Verify user context was injected
		userID := ctx.UserValue("user_id")
		if userID == nil {
			t.Error("Expected user_id to be set in context")
		}
		
		if userID != user.ID {
			t.Errorf("Expected user_id %v, got %v", user.ID, userID)
		}
		
		ctx.SetStatusCode(fasthttp.StatusOK)
		ctx.SetBodyString("authenticated success")
	}
	
	wrappedHandler := middleware.Handler(testHandler)
	
	ctx := &fasthttp.RequestCtx{}
	ctx.Request.SetRequestURI("/v1/chat/completions")
	ctx.Request.Header.SetMethod("POST")
	ctx.Request.Header.Set("Authorization", "Bearer "+mockToken)
	
	wrappedHandler(ctx)
	
	if ctx.Response.StatusCode() != fasthttp.StatusOK {
		t.Errorf("Expected status 200 for valid auth, got %d", ctx.Response.StatusCode())
	}
}

func TestAuthConfig_DefaultConfig(t *testing.T) {
	config := DefaultAuthConfig()
	
	if config == nil {
		t.Fatal("DefaultAuthConfig returned nil")
	}
	
	// Verify protected routes
	expectedProtected := []string{"/v1/*", "/metrics", "/api/*"}
	if len(config.ProtectedRoutes) != len(expectedProtected) {
		t.Errorf("Expected %d protected routes, got %d", 
			len(expectedProtected), len(config.ProtectedRoutes))
	}
	
	for i, expected := range expectedProtected {
		if i >= len(config.ProtectedRoutes) || config.ProtectedRoutes[i] != expected {
			t.Errorf("Expected protected route %s at index %d, got %v", 
				expected, i, config.ProtectedRoutes)
		}
	}
	
	// Verify public routes
	expectedPublic := []string{"/auth/*", "/", "/ui/*", "/app/*", "/static/*"}
	if len(config.PublicRoutes) != len(expectedPublic) {
		t.Errorf("Expected %d public routes, got %d", 
			len(expectedPublic), len(config.PublicRoutes))
	}
	
	for i, expected := range expectedPublic {
		if i >= len(config.PublicRoutes) || config.PublicRoutes[i] != expected {
			t.Errorf("Expected public route %s at index %d, got %v", 
				expected, i, config.PublicRoutes)
		}
	}
}

// Benchmark tests for performance
func BenchmarkAuthMiddleware_PublicRoute(b *testing.B) {
	middleware, _ := setupAuthMiddlewareTest(&testing.T{})
	
	testHandler := func(ctx *fasthttp.RequestCtx) {
		ctx.SetStatusCode(fasthttp.StatusOK)
	}
	
	wrappedHandler := middleware.Handler(testHandler)
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctx := &fasthttp.RequestCtx{}
		ctx.Request.SetRequestURI("/auth/login")
		wrappedHandler(ctx)
	}
}

func BenchmarkAuthMiddleware_ProtectedRouteNoAuth(b *testing.B) {
	middleware, _ := setupAuthMiddlewareTest(&testing.T{})
	
	testHandler := func(ctx *fasthttp.RequestCtx) {
		ctx.SetStatusCode(fasthttp.StatusOK)
	}
	
	wrappedHandler := middleware.Handler(testHandler)
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctx := &fasthttp.RequestCtx{}
		ctx.Request.SetRequestURI("/v1/chat/completions")
		wrappedHandler(ctx)
	}
}